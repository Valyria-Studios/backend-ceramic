function _check_private_redeclaration(obj, privateCollection) {
    if (privateCollection.has(obj)) {
        throw new TypeError("Cannot initialize the same private elements twice on an object");
    }
}
function _class_apply_descriptor_get(receiver, descriptor) {
    if (descriptor.get) {
        return descriptor.get.call(receiver);
    }
    return descriptor.value;
}
function _class_apply_descriptor_set(receiver, descriptor, value) {
    if (descriptor.set) {
        descriptor.set.call(receiver, value);
    } else {
        if (!descriptor.writable) {
            throw new TypeError("attempted to set read only private field");
        }
        descriptor.value = value;
    }
}
function _class_extract_field_descriptor(receiver, privateMap, action) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to " + action + " private field on non-instance");
    }
    return privateMap.get(receiver);
}
function _class_private_field_get(receiver, privateMap) {
    var descriptor = _class_extract_field_descriptor(receiver, privateMap, "get");
    return _class_apply_descriptor_get(receiver, descriptor);
}
function _class_private_field_init(obj, privateMap, value) {
    _check_private_redeclaration(obj, privateMap);
    privateMap.set(obj, value);
}
function _class_private_field_set(receiver, privateMap, value) {
    var descriptor = _class_extract_field_descriptor(receiver, privateMap, "set");
    _class_apply_descriptor_set(receiver, descriptor, value);
    return value;
}
import { SyncOptions } from '@ceramicnetwork/common';
import { ModelInstanceDocument } from '@ceramicnetwork/stream-model-instance';
import { StreamID, StreamRef } from '@ceramicnetwork/streamid';
import DataLoader from 'dataloader';
import { createDeterministicKey, getDeterministicCacheKey } from './deterministic.js';
import { queryConnection, queryOne } from './query.js';
export const DEFAULT_DETERMINISTIC_OPTIONS = {
    sync: SyncOptions.NEVER_SYNC
};
export function getKeyID(key) {
    return typeof key.id === 'string' ? StreamRef.from(key.id).toString() : key.id.toString();
}
/** @internal */ export function removeNullValues(content) {
    const copy = {
        ...content
    };
    for (const [key, value] of Object.entries(copy)){
        if (value == null) {
            delete copy[key];
        } else if (Array.isArray(value)) {
            copy[key] = value.map((item)=>{
                return typeof item === 'object' && !Array.isArray(item) && item != null ? removeNullValues(item) : item;
            });
        } else if (typeof value === 'object') {
            copy[key] = removeNullValues(value);
        }
    }
    return copy;
}
var _ceramic = /*#__PURE__*/ new WeakMap(), _deterministicKeys = /*#__PURE__*/ new WeakMap(), _useCache = /*#__PURE__*/ new WeakMap();
/**
 * The DocumentLoader class provides APIs to batch load and cache ModelInstanceDocument streams.
 *
 * It is exported by the {@linkcode loader} module.
 *
 * ```sh
 * import { DocumentLoader } from '@composedb/loader'
 * ```
 */ export class DocumentLoader extends DataLoader {
    /**
   * Add a ModelInstanceDocument to the local cache, if enabled.
   */ cache(stream) {
        if (!_class_private_field_get(this, _useCache)) {
            return false;
        }
        const key = {
            id: stream.id.toString()
        };
        this.clear(key).prime(key, stream);
        return true;
    }
    /**
   * Get or create the LoadKey for a deterministic stream.
   */ _getDeterministicKey(meta) {
        const cacheKey = getDeterministicCacheKey(meta);
        const existing = _class_private_field_get(this, _deterministicKeys).get(cacheKey);
        if (existing != null) {
            return existing;
        }
        const loadKeyPromise = createDeterministicKey(meta);
        _class_private_field_get(this, _deterministicKeys).set(cacheKey, loadKeyPromise);
        return loadKeyPromise;
    }
    /**
   * Create a new ModelInstanceDocument and add it to the cache, if enabled.
   */ async create(model, content, { controller, shouldIndex, ...options } = {}) {
        const metadata = {
            controller,
            model: model instanceof StreamID ? model : StreamID.fromString(model),
            shouldIndex
        };
        const stream = await ModelInstanceDocument.create(_class_private_field_get(this, _ceramic), removeNullValues(content), metadata, options);
        this.cache(stream);
        return stream;
    }
    /**
   * Load a ModelInstanceDocument from the cache (if enabled) or remotely.
   */ async load(key) {
        return await super.load(key);
    }
    /**
   * Load a deterministic stream and add it to the cache.
   */ async _loadDeterministic(meta, options = {}) {
        const opts = {
            ...DEFAULT_DETERMINISTIC_OPTIONS,
            ...options
        };
        const key = await this._getDeterministicKey(meta);
        const doc = await this.load({
            ...key,
            opts
        });
        return (options.onlyIndexed === false || doc.metadata.shouldIndex !== false) && (!options.ignoreEmpty || doc.content != null) ? doc : null;
    }
    /**
   * Create or load a deterministic ModelInstanceDocument and cache it.
   */ async loadSingle(controller, model, options) {
        return await this._loadDeterministic({
            controller,
            model
        }, options);
    }
    /**
   * Create or load a deterministic ModelInstanceDocument using the SET account
   * relation and cache it.
   */ async loadSet(controller, model, unique, options) {
        return await this._loadDeterministic({
            controller,
            model,
            unique
        }, options);
    }
    /**
   * Update a ModelInstanceDocument after loading the stream remotely, bypassing the cache.
   */ async update(streamID, content, { replace, shouldIndex, version, ...options } = {}) {
        const key = {
            id: streamID
        };
        this.clear(key);
        const stream = await this.load(key);
        if (version != null && stream.commitId.toString() !== version) {
            throw new Error('Stream version mismatch');
        }
        const newContent = replace ? content : {
            ...stream.content ?? {},
            ...content
        };
        const metadata = typeof shouldIndex === 'undefined' ? undefined : {
            shouldIndex
        };
        await stream.replace(removeNullValues(newContent), metadata, options);
        return stream;
    }
    /**
   * Query the index for multiple ModelInstanceDocument streams and cache the results.
   */ async queryConnection(query) {
        const connection = await queryConnection(_class_private_field_get(this, _ceramic), query);
        for (const edge of connection.edges){
            if (edge.node != null) {
                this.cache(edge.node);
            }
        }
        return connection;
    }
    /**
   * Query the index for a single ModelInstanceDocument stream and cache it.
   */ async queryOne(query) {
        const doc = await queryOne(_class_private_field_get(this, _ceramic), query);
        if (doc != null) {
            this.cache(doc);
        }
        return doc;
    }
    constructor(params){
        super(async (keys)=>{
            if (!params.cache) {
                // Disable cache but keep batching behavior - from https://github.com/graphql/dataloader#disabling-cache
                this.clearAll();
            }
            const results = await params.ceramic.multiQuery(keys.map(({ id, ...rest })=>({
                    streamId: id,
                    ...rest
                })), params.multiqueryTimeout);
            return keys.map((key)=>{
                const id = getKeyID(key);
                const doc = results[id];
                return doc ? doc : new Error(`Failed to load document: ${id}`);
            });
        }, {
            cache: true,
            cacheKeyFn: getKeyID,
            cacheMap: params.cache != null && typeof params.cache !== 'boolean' ? params.cache : undefined
        });
        _class_private_field_init(this, _ceramic, {
            writable: true,
            value: void 0
        });
        _class_private_field_init(this, _deterministicKeys, {
            writable: true,
            value: void 0
        });
        _class_private_field_init(this, _useCache, {
            writable: true,
            value: void 0
        });
        _class_private_field_set(this, _ceramic, params.ceramic);
        _class_private_field_set(this, _deterministicKeys, params.deterministicKeysCache ?? new Map());
        _class_private_field_set(this, _useCache, !!params.cache);
    }
}
