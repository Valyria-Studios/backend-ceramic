import { type BaseQuery, type CreateOpts, type LoadOpts, type UpdateOpts } from '@ceramicnetwork/common';
import { ModelInstanceDocument } from '@ceramicnetwork/stream-model-instance';
import { StreamID } from '@ceramicnetwork/streamid';
import type { CeramicAPI } from '@composedb/types';
import DataLoader from 'dataloader';
import type { Connection } from 'graphql-relay';
import { type GenesisMetadata } from './deterministic.js';
import { type ConnectionQuery } from './query.js';
import type { DeterministicKeysCache, DocumentCache, LoadKey } from './types.js';
export declare const DEFAULT_DETERMINISTIC_OPTIONS: LoadOpts;
export type CreateOptions = CreateOpts & {
    controller?: string;
    shouldIndex?: boolean;
};
export type DeterministicLoadOptions = CreateOpts & {
    ignoreEmpty?: boolean;
    onlyIndexed?: boolean;
};
export type UpdateDocOptions = {
    replace?: boolean;
    shouldIndex?: boolean;
    version?: string;
};
export type UpdateOptions = UpdateOpts & UpdateDocOptions;
export type DocumentLoaderParams = {
    /**
     * A Ceramic client instance
     */
    ceramic: CeramicAPI;
    /**
     * A supported cache implementation, `true` to use the default implementation or `false` to
     * disable the cache (default)
     */
    cache?: DocumentCache | boolean;
    /**
     * Optional cache for deterministic streams keys
     */
    deterministicKeysCache?: DeterministicKeysCache;
    /**
     * MultiQuery request timeout in milliseconds
     */
    multiqueryTimeout?: number;
};
export declare function getKeyID(key: LoadKey): string;
/** @internal */
export declare function removeNullValues(content: Record<string, unknown>): Record<string, unknown>;
/**
 * The DocumentLoader class provides APIs to batch load and cache ModelInstanceDocument streams.
 *
 * It is exported by the {@linkcode loader} module.
 *
 * ```sh
 * import { DocumentLoader } from '@composedb/loader'
 * ```
 */
export declare class DocumentLoader extends DataLoader<LoadKey, ModelInstanceDocument, string> {
    #private;
    constructor(params: DocumentLoaderParams);
    /**
     * Add a ModelInstanceDocument to the local cache, if enabled.
     */
    cache(stream: ModelInstanceDocument): boolean;
    /**
     * Get or create the LoadKey for a deterministic stream.
     */
    _getDeterministicKey(meta: GenesisMetadata): Promise<LoadKey>;
    /**
     * Create a new ModelInstanceDocument and add it to the cache, if enabled.
     */
    create<T extends Record<string, unknown> = Record<string, unknown>>(model: string | StreamID, content: T, { controller, shouldIndex, ...options }?: CreateOptions): Promise<ModelInstanceDocument<T>>;
    /**
     * Load a ModelInstanceDocument from the cache (if enabled) or remotely.
     */
    load<T extends Record<string, unknown> = Record<string, unknown>>(key: LoadKey): Promise<ModelInstanceDocument<T>>;
    /**
     * Load a deterministic stream and add it to the cache.
     */
    _loadDeterministic<T extends Record<string, unknown> = Record<string, unknown>>(meta: GenesisMetadata, options?: DeterministicLoadOptions): Promise<ModelInstanceDocument<T> | null>;
    /**
     * Create or load a deterministic ModelInstanceDocument and cache it.
     */
    loadSingle<T extends Record<string, unknown> = Record<string, unknown>>(controller: string, model: string | StreamID, options?: DeterministicLoadOptions): Promise<ModelInstanceDocument<T> | null>;
    /**
     * Create or load a deterministic ModelInstanceDocument using the SET account
     * relation and cache it.
     */
    loadSet<T extends Record<string, unknown> = Record<string, unknown>>(controller: string, model: string | StreamID, unique: Array<string>, options?: DeterministicLoadOptions): Promise<ModelInstanceDocument<T> | null>;
    /**
     * Update a ModelInstanceDocument after loading the stream remotely, bypassing the cache.
     */
    update<T extends Record<string, unknown> = Record<string, unknown>>(streamID: string | StreamID, content: T, { replace, shouldIndex, version, ...options }?: UpdateOptions): Promise<ModelInstanceDocument<T>>;
    /**
     * Query the index for multiple ModelInstanceDocument streams and cache the results.
     */
    queryConnection(query: ConnectionQuery): Promise<Connection<ModelInstanceDocument | null>>;
    /**
     * Query the index for a single ModelInstanceDocument stream and cache it.
     */
    queryOne(query: BaseQuery): Promise<ModelInstanceDocument | null>;
}
