import type { BaseQuery, CreateOpts, UpdateOpts } from '@ceramicnetwork/common';
import type { ModelInstanceDocument } from '@ceramicnetwork/stream-model-instance';
import type { CommitID, StreamID } from '@ceramicnetwork/streamid';
import { type DocumentCache, DocumentLoader } from '@composedb/loader';
import type { CeramicAPI } from '@composedb/types';
export type UpsertOptions = CreateOpts & {
    shouldIndex?: boolean;
};
export type ContextParams = {
    /**
     * Optional cache for documents.
     */
    cache?: DocumentCache | boolean;
    /**
     * Ceramic client instance.
     */
    ceramic: CeramicAPI;
    /**
     * Fallback viewer ID to use when the Ceramic instance is not authenticated.
     */
    fallbackViewerID?: string | null;
    /**
     * @internal
     */
    loader?: DocumentLoader;
};
export type Context = {
    /**
     * Returns whether the Ceramic client instance used internally is authenticated or not. When not
     * authenticated, mutations will fail.
     */
    isAuthenticated: () => boolean;
    /**
     * Ceramic client instance used internally.
     */
    ceramic: CeramicAPI;
    /**
     * Document loader instance used internally.
     */
    loader: DocumentLoader;
    /**
     * ID of the current viewer (authenticated DID), if set.
     */
    getViewerID: () => string | null;
    /**
     * Load a document by ID, using the cache if possible.
     */
    loadDoc: <Content extends Record<string, unknown>>(id: string | CommitID | StreamID, fresh?: boolean) => Promise<ModelInstanceDocument<Content> | null>;
    /**
     * Create or update a document using the SINGLE account relation with the
     * given model and content.
     */
    upsertSingle: <Content extends Record<string, unknown>>(model: string, content: Content, options?: UpsertOptions) => Promise<ModelInstanceDocument<Content> | null>;
    /**
     * Create or update a document using the SET account relation with the given
     * model, content and unique fields value.
     */
    upsertSet: <Content extends Record<string, unknown>>(model: string, unique: Array<string>, content: Content, options?: UpsertOptions) => Promise<ModelInstanceDocument<Content> | null>;
    /**
     * Enable indexing for an existing document.
     */
    enableDocIndexing: (id: string, shouldIndex: boolean, opts?: UpdateOpts) => Promise<void>;
    /**
     * Query the index for the total number of documents matching the query parameters.
     */
    queryCount: (query: BaseQuery) => Promise<number>;
};
export declare function createContext(params: ContextParams): Context;
