/** @internal */ export function streamIDToString(id) {
    return typeof id === 'string' ? id : id.toString();
}
/** @internal */ export function applyMap(inputs, callFunc) {
    return Object.entries(inputs).reduce((acc, [key, value])=>{
        acc[key] = callFunc(value);
        return acc;
    }, {});
}
/** @internal */ export async function promiseMap(inputs, callFunc) {
    const results = await Promise.all(Object.values(inputs).map((value)=>callFunc(value)));
    return Object.keys(inputs).reduce((acc, key, i)=>{
        acc[key] = results[i];
        return acc;
    }, {});
}
/** @internal */ export function sortKeys(object) {
    return Object.keys(object).sort().reduce((acc, key)=>{
        // @ts-ignore
        acc[key] = object[key];
        return acc;
    }, {});
}
const RELATION_VIEW_SOURCES = {
    relationDocument: 'document',
    relationFrom: 'queryConnection',
    relationCountFrom: 'queryCount',
    relationSetFrom: 'set'
};
const RELATION_VIEW_TYPES = Object.keys(RELATION_VIEW_SOURCES);
/** @internal */ export function isRelationViewDefinition(view) {
    return RELATION_VIEW_TYPES.includes(view.type);
}
/** @internal */ export function assertRelationViewDefinition(view) {
    if (!isRelationViewDefinition(view)) {
        throw new Error(`Invalid relation view: ${view.type}`);
    }
}
/** @internal */ export function viewDefinitionToRuntimeRelation(view) {
    assertRelationViewDefinition(view);
    return {
        source: RELATION_VIEW_SOURCES[view.type],
        model: view.model,
        property: view.property
    };
}
/** @internal */ export function viewDefinitionToRuntime(view) {
    switch(view.type){
        case 'documentAccount':
        case 'documentVersion':
            return {
                type: 'view',
                viewType: view.type
            };
        case 'relationCountFrom':
        case 'relationDocument':
        case 'relationFrom':
        case 'relationSetFrom':
            return {
                type: 'view',
                viewType: 'relation',
                relation: viewDefinitionToRuntimeRelation(view)
            };
        default:
            // @ts-ignore unexpected view type
            throw new Error(`Unsupported view type: ${view.type}`);
    }
}
/** @internal */ export function viewRuntimeToModel(field) {
    if (field.viewType === 'relation') {
        const { model, property, source } = field.relation;
        if (source === 'document') {
            return {
                type: 'relationDocument',
                model,
                property
            };
        }
        if (model == null) {
            throw new Error(`Missing model for ${source} relation view`);
        }
        switch(source){
            case 'queryConnection':
                return {
                    type: 'relationFrom',
                    model,
                    property
                };
            case 'queryCount':
                return {
                    type: 'relationCountFrom',
                    model,
                    property
                };
            case 'set':
                return {
                    type: 'relationSetFrom',
                    model,
                    property
                };
        }
    }
    return {
        type: field.viewType
    };
}
