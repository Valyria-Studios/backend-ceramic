var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _AnchorProcessingLoop_loop, _AnchorProcessingLoop_anchorStoreQueue, _AnchorProcessingLoop_anchorPollingMetrics;
import { ProcessingLoop } from './processing-loop.js';
import { AnchorRequestCarFileReader } from './anchor-request-car-file-reader.js';
import { TimeableMetric, SinceField } from '@ceramicnetwork/observability';
const METRICS_REPORTING_INTERVAL_MS = 10000;
const DEFAULT_CONCURRENCY = 25;
export class AnchorProcessingLoop {
    constructor(batchSize, cas, store, logger, eventHandler, anchorStoreQueue) {
        _AnchorProcessingLoop_loop.set(this, void 0);
        _AnchorProcessingLoop_anchorStoreQueue.set(this, void 0);
        _AnchorProcessingLoop_anchorPollingMetrics.set(this, void 0);
        __classPrivateFieldSet(this, _AnchorProcessingLoop_anchorStoreQueue, anchorStoreQueue, "f");
        __classPrivateFieldSet(this, _AnchorProcessingLoop_anchorPollingMetrics, new TimeableMetric(SinceField.TIMESTAMP, 'anchorRequestAge', METRICS_REPORTING_INTERVAL_MS), "f");
        const concurrency = Number(process.env.CERAMIC_ANCHOR_POLLING_CONCURRENCY) || DEFAULT_CONCURRENCY;
        __classPrivateFieldSet(this, _AnchorProcessingLoop_loop, new ProcessingLoop(logger, concurrency, store.infiniteList(batchSize), async (streamId) => {
            try {
                logger.verbose(`Loading pending anchor metadata for Stream ${streamId} from AnchorRequestStore`);
                const entry = await store.load(streamId);
                const event = await cas.getStatusForRequest(streamId, entry.cid).catch(async (error) => {
                    logger.warn(`No request present on CAS for ${entry.cid} of ${streamId}: ${error}`);
                    const requestCAR = await eventHandler.buildRequestCar(streamId, entry.cid);
                    return cas.create(new AnchorRequestCarFileReader(requestCAR));
                });
                const isTerminal = await eventHandler.handle(event);
                logger.verbose(`Anchor event with status ${event.status} for commit CID ${entry.cid} of Stream ${streamId} handled successfully`);
                if (isTerminal) {
                    __classPrivateFieldGet(this, _AnchorProcessingLoop_anchorPollingMetrics, "f").record(entry);
                    await __classPrivateFieldGet(this, _AnchorProcessingLoop_anchorStoreQueue, "f").run(streamId.toString(), async () => {
                        const loaded = await store.load(streamId);
                        if (loaded.cid.equals(entry.cid)) {
                            await store.remove(streamId);
                            logger.verbose(`Entry from AnchorRequestStore for Stream ${streamId} removed successfully`);
                        }
                    });
                }
            }
            catch (err) {
                logger.err(`Error while processing entry from the AnchorRequestStore for StreamID ${streamId}: ${err}`);
            }
        }), "f");
    }
    start() {
        __classPrivateFieldGet(this, _AnchorProcessingLoop_anchorPollingMetrics, "f").startPublishingStats();
        void __classPrivateFieldGet(this, _AnchorProcessingLoop_loop, "f").start();
    }
    async stop() {
        __classPrivateFieldGet(this, _AnchorProcessingLoop_anchorPollingMetrics, "f").stopPublishingStats();
        return __classPrivateFieldGet(this, _AnchorProcessingLoop_loop, "f").stop();
    }
}
_AnchorProcessingLoop_loop = new WeakMap(), _AnchorProcessingLoop_anchorStoreQueue = new WeakMap(), _AnchorProcessingLoop_anchorPollingMetrics = new WeakMap();
//# sourceMappingURL=anchor-processing-loop.js.map