import type { AnchorEvent, AnchorProof, FetchRequest } from '@ceramicnetwork/common';
import type { StreamID } from '@ceramicnetwork/streamid';
import type { CID } from 'multiformats/cid';
import type { CAR } from 'cartonne';
import type { AnchorRequestStore } from '../store/anchor-request-store.js';
import type { AnchorRequestCarFileReader } from './anchor-request-car-file-reader.js';
import { CeramicSigner } from '@ceramicnetwork/common';
export declare type AnchorLoopHandler = {
    buildRequestCar(streamId: StreamID, tip: CID): Promise<CAR>;
    handle(event: AnchorEvent): Promise<boolean>;
};
export interface AnchorService {
    readonly validator: AnchorValidator;
    init(store: AnchorRequestStore, eventHandler: AnchorLoopHandler): Promise<void>;
    url: string;
    assertCASAccessible(): void;
    requestAnchor(carFile: CAR): Promise<AnchorEvent>;
    getSupportedChains(): Promise<Array<string>>;
    close(): Promise<void>;
}
export interface AuthenticatedAnchorService extends AnchorService {
    auth: AnchorServiceAuth;
}
export interface AnchorServiceAuth {
    init(): Promise<void>;
    signer: CeramicSigner;
    sendAuthenticatedRequest: FetchRequest;
}
export interface AnchorValidator {
    chainId: string;
    ethereumRpcEndpoint: string | null;
    init(chainId: string | null): Promise<void>;
    validateChainInclusion(anchorProof: AnchorProof): Promise<number>;
}
export interface CASClient {
    supportedChains(): Promise<Array<string>>;
    assertCASAccessible(): void;
    create(carFileReader: AnchorRequestCarFileReader): Promise<AnchorEvent>;
    getStatusForRequest(streamId: StreamID, commitCID: CID): Promise<AnchorEvent>;
    close(): Promise<void>;
}
export declare class NotSingleChainError extends Error {
    constructor();
}
//# sourceMappingURL=anchor-service.d.ts.map