import { CommitID, StreamID } from '@ceramicnetwork/streamid';
import { AnchorEvent, AnchorOpts, CreateOpts, DiagnosticsLogger, LoadOpts, PublishOpts, StreamState, UpdateOpts } from '@ceramicnetwork/common';
import type { LocalIndexApi } from '@ceramicnetwork/indexing';
import { PinStore } from '../store/pin-store.js';
import { ExecutionQueue } from './execution-queue.js';
import { RunningState } from './running-state.js';
import type { Dispatcher } from '../dispatcher.js';
import type { HandlersMap } from '../handlers-map.js';
import { Observable } from 'rxjs';
import { StateCache } from './state-cache.js';
import { SnapshotState } from './snapshot-state.js';
import { IKVStore } from '../store/ikv-store.js';
import { AnchorRequestStore } from '../store/anchor-request-store.js';
import { StreamLoader } from '../stream-loading/stream-loader.js';
import { StreamUpdater } from '../stream-loading/stream-updater.js';
import { CID } from 'multiformats/cid';
import type { AnchorLoopHandler, AnchorService } from '../anchor/anchor-service.js';
import type { AnchorRequestCarBuilder } from '../anchor/anchor-request-car-builder.js';
import { type Feed } from '../feed.js';
import { IReconApi, ReconEventFeedResponse } from '../recon.js';
export declare type RepositoryDependencies = {
    dispatcher: Dispatcher;
    pinStore: PinStore;
    keyValueStore: IKVStore;
    anchorRequestStore: AnchorRequestStore;
    handlers: HandlersMap;
    anchorService: AnchorService;
    indexing: LocalIndexApi;
    streamLoader: StreamLoader;
    streamUpdater: StreamUpdater;
    anchorRequestCarBuilder: AnchorRequestCarBuilder;
};
export declare class Repository {
    #private;
    private readonly recon;
    private readonly logger;
    readonly loadingQ: ExecutionQueue;
    readonly executionQ: ExecutionQueue;
    readonly inmemory: StateCache<RunningState>;
    private readonly feed;
    private reconEventFeedSubscription;
    constructor(cacheLimit: number, concurrencyLimit: number, feed: Feed, recon: IReconApi, logger: DiagnosticsLogger);
    injectKeyValueStore(stateStore: IKVStore): Promise<void>;
    init(): Promise<void>;
    get pinStore(): PinStore;
    private get streamLoader();
    private get streamUpdater();
    get numPendingAnchors(): number;
    private get anchorService();
    private get dispatcher();
    get anchorRequestStore(): AnchorRequestStore;
    get index(): LocalIndexApi;
    setDeps(deps: RepositoryDependencies): void;
    load(streamId: StreamID, loadOptions?: LoadOpts, checkCacaoExpiration?: boolean): Promise<RunningState>;
    private _updateStateIfPinned_safe;
    private _updateStateIfPinned;
    private _fromMemory;
    private _fromStreamStateStore;
    private _fromMemoryOrStoreWithSyncStatus;
    private _loadStreamFromNetwork;
    private _genesisFromNetwork;
    private _sync;
    private _resyncStreamFromNetwork;
    loadAtCommit(commitId: CommitID, opts: LoadOpts): Promise<SnapshotState>;
    private _atCommit;
    loadAtTime(streamId: StreamID, opts: LoadOpts): Promise<SnapshotState>;
    applyCommit(streamId: StreamID, commit: any, opts: UpdateOpts): Promise<RunningState>;
    handleReconEvents(response: ReconEventFeedResponse): Promise<void>;
    handleUpdateFromNetwork(streamId: StreamID, tip: CID, model?: StreamID): Promise<void>;
    private _handleTip;
    anchor(state$: RunningState, opts: AnchorOpts): Promise<void>;
    handleAnchorEvent(state$: RunningState, anchorEvent: AnchorEvent): Promise<boolean>;
    private _handleAnchorCommit;
    private _applyWriteOpts;
    private _publishTip;
    private _handlePinOpts;
    createStreamFromGenesis(type: number, genesis: any, opts?: CreateOpts): Promise<RunningState>;
    fromMemoryOrStore(streamId: StreamID): Promise<RunningState | undefined>;
    fromMemoryOrStore_UNSAFE(streamId: StreamID): Promise<RunningState | undefined>;
    streamState(streamId: StreamID): Promise<StreamState | undefined>;
    private _registerRunningState;
    pin(state$: RunningState, force?: boolean): Promise<void>;
    private _pin_UNSAFE;
    unpin(state$: RunningState, opts?: PublishOpts): Promise<void>;
    listPinned(streamId?: StreamID): Promise<string[]>;
    markPinnedAndSynced(streamId: StreamID): void;
    markUnpinned(streamId: StreamID): void;
    private _wasPinnedStreamSynced;
    randomPinnedStreamState(): Promise<StreamState | null>;
    private _indexStreamIfNeeded;
    updates$(init: StreamState): Observable<StreamState>;
    anchorLoopHandler(): AnchorLoopHandler;
    close(): Promise<void>;
}
//# sourceMappingURL=repository.d.ts.map