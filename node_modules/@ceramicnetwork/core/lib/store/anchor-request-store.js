var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _AnchorRequestStore_shouldStop, _AnchorRequestStore_logger, _AnchorRequestStore_infiniteListBatchTimeoutMs;
import { StreamID } from '@ceramicnetwork/streamid';
import { ObjectStore } from './object-store.js';
import { CID } from 'multiformats/cid';
import { StreamUtils } from '@ceramicnetwork/common';
import { ServiceMetrics as Metrics } from '@ceramicnetwork/observability';
const DEFAULT_BATCH_TIMEOUT_MS = 60 * 1000;
const ANCHOR_POLLING_PROCESSED = 'anchor_polling_processed';
function generateKey(object) {
    if (object) {
        return object.toString();
    }
    else {
        return undefined;
    }
}
export function serializeAnchorRequestData(value) {
    return JSON.stringify({
        cid: value.cid.toString(),
        timestamp: value.timestamp,
        genesis: StreamUtils.serializeCommit(value.genesis),
    });
}
export function deserializeAnchorRequestData(serialized) {
    const parsed = JSON.parse(serialized);
    return {
        cid: CID.parse(parsed.cid),
        timestamp: parsed.timestamp,
        genesis: StreamUtils.deserializeCommit(parsed.genesis),
    };
}
export class AnchorRequestStore extends ObjectStore {
    constructor(logger, infiniteListBatchTimeoutMs = DEFAULT_BATCH_TIMEOUT_MS) {
        super(generateKey, serializeAnchorRequestData, deserializeAnchorRequestData);
        _AnchorRequestStore_shouldStop.set(this, void 0);
        _AnchorRequestStore_logger.set(this, void 0);
        _AnchorRequestStore_infiniteListBatchTimeoutMs.set(this, void 0);
        this.useCaseName = 'anchor-requests';
        __classPrivateFieldSet(this, _AnchorRequestStore_logger, logger, "f");
        __classPrivateFieldSet(this, _AnchorRequestStore_infiniteListBatchTimeoutMs, infiniteListBatchTimeoutMs, "f");
    }
    exists(key) {
        return this.store.exists(generateKey(key), this.useCaseName);
    }
    async *list(batchSize = 1) {
        let gt = undefined;
        do {
            const batch = await this.store.find({
                limit: batchSize,
                useCaseName: this.useCaseName,
                gt: generateKey(gt),
            });
            if (batch.length > 0) {
                gt = StreamID.fromString(batch[batch.length - 1].key);
                yield batch.map((item) => {
                    return {
                        key: StreamID.fromString(item.key),
                        value: deserializeAnchorRequestData(item.value),
                    };
                });
            }
            else {
                return;
            }
        } while (true);
    }
    async *infiniteList(batchSize = 1, restartDelay = 1000) {
        let gt = undefined;
        let numEntries = 0;
        do {
            try {
                let timeout;
                const timeoutPromise = new Promise((resolve) => {
                    timeout = setTimeout(() => {
                        __classPrivateFieldGet(this, _AnchorRequestStore_logger, "f").warn(`Timed out while waiting for AnchorRequestStore to fetch a batch`);
                        resolve(null);
                    }, __classPrivateFieldGet(this, _AnchorRequestStore_infiniteListBatchTimeoutMs, "f"));
                });
                __classPrivateFieldGet(this, _AnchorRequestStore_logger, "f").debug(`Fetching batch from AnchorRequestStore starting at key ${gt}`);
                const batchPromise = this.store.find({
                    limit: batchSize,
                    useCaseName: this.useCaseName,
                    gt: generateKey(gt),
                });
                const batch = await Promise.race([batchPromise, timeoutPromise]);
                clearTimeout(timeout);
                if (batch && batch.length > 0) {
                    gt = StreamID.fromString(batch[batch.length - 1].key);
                    for (const item of batch) {
                        numEntries++;
                        yield StreamID.fromString(item.key);
                    }
                }
                else {
                    __classPrivateFieldGet(this, _AnchorRequestStore_logger, "f").debug(`Anchor polling loop processed ${numEntries} entries from the AnchorRequestStore. Restarting loop.`);
                    Metrics.observe(ANCHOR_POLLING_PROCESSED, numEntries);
                    await new Promise((resolve) => setTimeout(resolve, restartDelay));
                    gt = undefined;
                    numEntries = 0;
                }
            }
            catch (err) {
                __classPrivateFieldGet(this, _AnchorRequestStore_logger, "f").err(`Error querying the AnchorRequestStore: ${err}`);
            }
        } while (!__classPrivateFieldGet(this, _AnchorRequestStore_shouldStop, "f"));
        __classPrivateFieldGet(this, _AnchorRequestStore_logger, "f").debug(`AnchorRequestStore processing loop shutting down`);
    }
    async close() {
        __classPrivateFieldGet(this, _AnchorRequestStore_logger, "f").debug(`Closing AnchorRequestStore`);
        __classPrivateFieldSet(this, _AnchorRequestStore_shouldStop, true, "f");
        await super.close();
    }
}
_AnchorRequestStore_shouldStop = new WeakMap(), _AnchorRequestStore_logger = new WeakMap(), _AnchorRequestStore_infiniteListBatchTimeoutMs = new WeakMap();
//# sourceMappingURL=anchor-request-store.js.map